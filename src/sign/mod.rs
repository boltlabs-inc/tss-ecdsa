// Copyright (c) 2023 Bolt Labs Holdings, Inc
//
// This source code is licensed under both the MIT license found in the
// LICENSE-MIT file in the root directory of this source tree and the Apache
// License, Version 2.0 found in the LICENSE-APACHE file in the root directory
// of this source tree.

//! This module implements two signing protocols. [^cite]
//!
//! It includes both the interactive signing protocol (described in Figure 3)
//! and the non-interactive protocol (described in Figure 8).
//!
//! [^cite]: Ran Canetti, Rosario Gennaro, Steven Goldfeder, Nikolaos
//! Makriyannis, and Udi Peled. UC Non-Interactive, Proactive, Threshold ECDSA
//! with Identifiable Aborts. [EPrint archive,
//! 2021](https://eprint.iacr.org/archive/2021/060/1634824619.pdf).
//!
//! We expose our signature type in terms of the [`k256`] crate.

mod interactive_sign;
mod non_interactive_sign;

use serde::{Deserialize, Serialize};
use tracing::error;

use crate::{curve::CT, errors::{CallerError, InternalError, Result}};

pub use interactive_sign::participant::{Input as InteractiveInput, InteractiveSignParticipant};
pub use non_interactive_sign::participant::{Input, SignParticipant};
use sha3::{Digest, Keccak256};

/// ECDSA signature on a message.
///
/// When generated by this library, the signature will be produced by the
/// threshold ECDSA algorithm by Canetti et al.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Signature<C: CT>(k256::ecdsa::Signature, std::marker::PhantomData<C>);

impl<C: CT> Signature<C> {
    pub(super) fn try_from_scalars(r: C::Scalar, s: C::Scalar) -> Result<Self> {
        Ok(Self(k256::ecdsa::Signature::from_scalars(r, s)
             .map_err(|e| {
                 error!("Failed to generate `Signature` from `Scalar`s but they should be correctly formatted {e:?}");
                 InternalError::InternalInvariantFailed
             })?,  std::marker::PhantomData::<C>)
            ) 
    }

    /// Compute the recovery ID of this signature using "trial recovery".
    /// This allows us to support Ethereum recoverable signatures.
    ///
    /// The correct message and public key corresponding to this signature must
    /// be used for this to succeed.
    ///
    /// **Note:** The message will be hashed with `keccak256`.
    pub fn recovery_id(
        &self,
        message: &[u8],
        public_key: &k256::ecdsa::VerifyingKey,
    ) -> Result<k256::ecdsa::RecoveryId> {
        let digest = Keccak256::new_with_prefix(message);
        let recover_id =
            k256::ecdsa::RecoveryId::trial_recovery_from_digest(public_key, digest, &self.0)
                .map_err(|e| {
                    error!("Failed to compute recovery ID for signature. Reason: {e:?}");
                    CallerError::SignatureTrialRecoveryFailed
                })?;
        Ok(recover_id)
    }
}

impl<C: CT> AsRef<k256::ecdsa::Signature> for Signature<C> {
    fn as_ref(&self) -> &k256::ecdsa::Signature {
        &self.0
    }
}

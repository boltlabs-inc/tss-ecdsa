// Copyright (c) 2023 Bolt Labs Holdings, Inc
//
// This source code is licensed under both the MIT license found in the
// LICENSE-MIT file in the root directory of this source tree and the Apache
// License, Version 2.0 found in the LICENSE-APACHE file in the root directory
// of this source tree.

//! This module instantiates a [`SignParticipant`] which implements the
//! signing protocol.

use rand::{CryptoRng, RngCore};

use crate::{
    errors::Result,
    messages::{Message, MessageType},
    participant::ProcessOutcome,
    protocol::ProtocolType,
    Identifier, ParticipantIdentifier, PresignRecord, ProtocolParticipant,
};

/// A participant that runs the signing protocol in Figure 8 of Canetti et
/// al[^cite].
///
/// Note that this only runs Figure 8. By itself, this corresponds to the
/// non-interactive signing protocol; it expects a
/// [`PresignRecord`](crate::PresignRecord) as input. It could be
/// used as a component to execute the interactive signing protocol, but this is
/// not yet implemented.
///
///
/// # Protocol input
/// The protocol takes two fields as input:
/// - a message digest, which is the hash of the message to be signed. This
///   library expects a 256-bit digest (e.g. produced by SHA3-256 (Keccak)).
/// - a [`PresignRecord`]. This must be fresh (never used for any other
///   execution of the threshold ECDSA protocol, even a failed run) and must
///   have been generated using the private share of the key under which the
///   caller desires a signature.
///
///
/// # Protocol output
/// Upon successful completion, the participant outputs a [`Signature`].
/// The signature is on the message which was used to produce the provided
///   input message digest. It verifies under the public verification key
/// corresponding to the private signing key used to produce the input
///   [`PresignRecord`].
///
/// # ðŸ”’ Storage requirement
/// The [`PresignRecord`] provided as input must be discarded; no copies should
/// remain after use.
///
/// [^cite]: Ran Canetti, Rosario Gennaro, Steven Goldfeder, Nikolaos
/// Makriyannis, and Udi Peled. UC Non-Interactive, Proactive, Threshold ECDSA
/// with Identifiable Aborts. [EPrint archive,
/// 2021](https://eprint.iacr.org/2021/060.pdf).

pub struct SignParticipant {}

/// Input for a [`SignParticipant`].
#[allow(unused)]
#[derive(Debug)]
pub struct Input {
    message_digest: Box<[u8; 32]>,
    presign_record: PresignRecord,
}

/// ECDSA signature on a message.
///
/// When generated by this library, the signature will be produced by the
/// threshold ECDSA algorithm by Canetti et al.
#[derive(Debug)]
pub struct Signature(k256::ecdsa::Signature);

/// Protocol status for [`SignParticipant`].
#[allow(unused)]
#[derive(Debug, PartialEq)]
pub enum Status {
    /// Participant has been initialized.
    Initialized,
    /// Participant has finished the sub-protocol.
    TerminatedSuccessfully,
}

#[allow(unused)]
impl ProtocolParticipant for SignParticipant {
    type Input = Input;
    type Output = Signature;
    type Status = Status;

    fn ready_type() -> MessageType {
        todo!()
    }

    fn protocol_type() -> ProtocolType {
        todo!()
    }

    fn new(
        sid: Identifier,
        id: ParticipantIdentifier,
        other_participant_ids: Vec<ParticipantIdentifier>,
        input: Self::Input,
    ) -> Result<Self>
    where
        Self: Sized,
    {
        todo!()
    }

    fn id(&self) -> ParticipantIdentifier {
        todo!()
    }

    fn other_ids(&self) -> &[ParticipantIdentifier] {
        todo!()
    }

    fn process_message<R: RngCore + CryptoRng>(
        &mut self,
        rng: &mut R,
        message: &Message,
    ) -> Result<ProcessOutcome<Self::Output>> {
        todo!()
    }

    fn status(&self) -> &Self::Status {
        todo!()
    }

    fn sid(&self) -> Identifier {
        todo!()
    }

    fn input(&self) -> &Self::Input {
        todo!()
    }

    fn is_ready(&self) -> bool {
        todo!()
    }
}
